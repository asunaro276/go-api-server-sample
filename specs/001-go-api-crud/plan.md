
# 実装計画: Go APIサーバー（ヘルスチェック・CRUD）

**ブランチ**: `001-go-api-crud` | **日付**: 2025-09-28 | **仕様**: `/specs/001-go-api-crud/spec.md`
**入力**: `/specs/001-go-api-crud/spec.md` からの機能仕様

## 実行フロー (/plan コマンドスコープ)
```
1. 入力パスから機能仕様を読み込み
   → 見つからない場合: ERROR "仕様がパス{path}にありません"
2. 技術コンテキストを記入（要明確化をスキャン）
   → コンテキストからプロジェクトタイプを検出（web=frontend+backend, mobile=app+api）
   → プロジェクトタイプに基づいて構成決定を設定
3. 憲章ドキュメントの内容に基づいて憲章チェックセクションを記入
4. 下記の憲章チェックセクションを評価
   → 違反が存在する場合: 複雑性追跡にドキュメント化
   → 正当化不可能の場合: ERROR "まずアプローチを簡素化してください"
   → 進捗追跡を更新: 初期憲章チェック
5. フェーズ0を実行 → research.md
   → 要明確化が残る場合: ERROR "未知の事項を解決してください"
6. フェーズ1を実行 → contracts, data-model.md, quickstart.md, エージェント固有テンプレートファイル（例：Claude Codeの場合`CLAUDE.md`、GitHub Copilotの場合`.github/copilot-instructions.md`、Gemini CLIの場合`GEMINI.md`、Qwen Codeの場合`QWEN.md`、opencodeの場合`AGENTS.md`）
7. 憲章チェックセクションを再評価
   → 新しい違反がある場合: 設計をリファクタリング、フェーズ1に戻る
   → 進捗追跡を更新: 設計後憲章チェック
8. フェーズ2を計画 → タスク生成アプローチを説明（tasks.mdは作成しない）
9. 停止 - /tasksコマンド準備完了
```

**重要**: /planコマンドはステップ7で停止。フェーズ2-4は他のコマンドで実行：
- フェーズ2: /tasksコマンドがtasks.mdを作成
- フェーズ3-4: 実装実行（手動またはツール経由）

## 概要
Clean ArchitectureとDomain-Driven Designの原則に基づいて構築されたGo言語のRESTful APIサーバーを実装します。ヘルスチェック機能とコンテンツ管理のCRUD操作を提供し、PostgreSQLデータベースにデータを永続化します。認証・認可機能は含まず、JSON形式でレスポンスを返します。

## 技術コンテキスト
**言語/バージョン**: Go 1.24+
**主要依存関係**: Gin (Webフレームワーク), GORM (ORM), testify/suite (テスト), mockery v3 (モック生成), testcontainers (統合テスト), golangci-lint (リント), air (ホットリロード)
**ストレージ**: PostgreSQL
**テスト**: testify/suite + testcontainers (リポジトリテスト) + mockery v3 (モック生成)
**対象プラットフォーム**: Linuxサーバー
**プロジェクトタイプ**: single (バックエンドAPIのみ)
**パフォーマンス目標**: APIレスポンス < 200ms p95
**制約**: メモリ使用量監視、適切なデータベースインデックス設計、SQLインジェクション対策
**規模/スコープ**: 基本的なCMSバックエンド、認証・認可なし、コンテンツCRUD操作

## 憲章チェック
*ゲート: フェーズ0調査前に通過必須。フェーズ1設計後に再チェック。*

### 初期憲章チェック: ✅ 合格
- ✅ **Clean Architecture準拠**: 4層構成（Domain→UseCase→Controller→Infrastructure）で実装予定
- ✅ **技術スタック標準**: Go 1.24+、Gin、GORM、PostgreSQL、testify、mockery v3 - 全て憲章標準と一致
- ✅ **TDD原則**: テスト駆動開発、実装前にテスト作成を計画
- ✅ **命名規約**: 小文字繋ぎ、1ユースケース1ファイル、スネークケース禁止を遵守予定
- ✅ **セキュリティ原則**: 入力値検証をController層で実装、GORM使用でSQLインジェクション対策
- ✅ **依存関係管理**: 依存性注入パターン使用、抽象化によるInfrastructure層との分離

**違反なし** - 複雑性追跡不要

## プロジェクト構成

### ドキュメント（この機能）
```
specs/[###-feature]/
├── plan.md              # このファイル（/planコマンド出力）
├── research.md          # フェーズ0出力（/planコマンド）
├── data-model.md        # フェーズ1出力（/planコマンド）
├── quickstart.md        # フェーズ1出力（/planコマンド）
├── contracts/           # フェーズ1出力（/planコマンド）
└── tasks.md             # フェーズ2出力（/tasksコマンド - /planでは作成されない）
```

### ソースコード（リポジトリルート）
```
# オプション1: 単一プロジェクト（デフォルト）
src/
├── models/
├── services/
├── cli/
└── lib/

tests/
├── integration/
└── unit/

# オプション2: Webアプリケーション（"frontend" + "backend"検出時）
backend/
├── src/
│   ├── models/
│   ├── services/
│   └── api/
└── tests/

frontend/
├── src/
│   ├── components/
│   ├── pages/
│   └── services/
└── tests/

# オプション3: モバイル + API（"iOS/Android"検出時）
api/
└── [上記backendと同じ]

ios/ または android/
└── [プラットフォーム固有構成]
```

**構成決定**: [技術コンテキストでweb/mobileアプリが示されない限りオプション1をデフォルト]

## フェーズ0: アウトライン & 調査
1. **上記技術コンテキストから未知事項を抽出**:
   - 各要明確化項目 → 調査タスク
   - 各依存関係 → ベストプラクティスタスク
   - 各統合 → パターンタスク

2. **調査エージェントを生成・派遣**:
   ```
   技術コンテキストの各未知事項について:
     Task: "機能コンテキスト{feature context}の{unknown}を調査"
   各技術選択について:
     Task: "{domain}での{tech}のベストプラクティスを発見"
   ```

3. **findings.mdでの調査結果統合** 以下の形式を使用:
   - 決定: [選択されたもの]
   - 根拠: [選択理由]
   - 検討した代替案: [他に評価したもの]

**出力**: すべての要明確化が解決されたresearch.md

## フェーズ1: 設計 & 契約
*前提条件: research.md完了*

1. **機能仕様からエンティティを抽出** → `data-model.md`:
   - エンティティ名、フィールド、関係
   - 要件からの検証ルール
   - 該当する場合は状態遷移

2. **機能要件からAPI契約を生成**:
   - 各ユーザーアクション → エンドポイント
   - 標準的なREST/GraphQLパターンを使用
   - OpenAPI/GraphQLスキーマを`/contracts/`に出力

3. **契約からコントラクトテストを生成**:
   - エンドポイントあたり1つのテストファイル
   - リクエスト/レスポンススキーマをアサート
   - テストは失敗する必要がある（まだ実装なし）

4. **ユーザーストーリーからテストシナリオを抽出**:
   - 各ストーリー → 統合テストシナリオ
   - クイックスタートテスト = ストーリー検証ステップ

5. **エージェントファイルを段階的に更新**（O(1)操作）:
   - `.specify/scripts/bash/update-agent-context.sh claude`を実行
     **重要**: 上記の通りに正確に実行。引数を追加・削除しない。
   - 存在する場合: 現在の計画からの新しい技術のみ追加
   - マーカー間の手動追加を保持
   - 最近の変更を更新（直近3つを保持）
   - トークン効率のため150行未満を維持
   - リポジトリルートに出力

**出力**: data-model.md, /contracts/*, 失敗するテスト, quickstart.md, エージェント固有ファイル

## フェーズ2: タスク計画アプローチ
*このセクションは/tasksコマンドが行うことを説明 - /plan中は実行しない*

**タスク生成戦略**:
- `.specify/templates/tasks-template.md`をベースとして読み込み
- フェーズ1設計ドキュメント（契約、データモデル、クイックスタート）からタスクを生成
- 各契約 → 契約テストタスク [P]
- 各エンティティ → モデル作成タスク [P]
- 各ユーザーストーリー → 統合テストタスク
- テストを通すための実装タスク

**順序戦略**:
- TDD順序: 実装前にテスト
- 依存関係順序: モデル→サービス→UIの順
- 独立ファイルには並列実行用に[P]をマーク

**推定出力**: tasks.mdに25-30の番号付き順序タスク

**重要**: このフェーズは/tasksコマンドで実行、/planではない

## フェーズ3+: 将来の実装
*これらのフェーズは/planコマンドのスコープ外*

**フェーズ3**: タスク実行（/tasksコマンドがtasks.mdを作成）
**フェーズ4**: 実装（憲章原則に従ってtasks.mdを実行）
**フェーズ5**: 検証（テスト実行、quickstart.md実行、パフォーマンス検証）

## 複雑性追跡
*憲章チェックで正当化が必要な違反がある場合のみ記入*

| 違反 | なぜ必要か | より簡単な代替案を却下した理由 |
|------|------------|--------------------------------|
| [例：4番目のプロジェクト] | [現在のニーズ] | [なぜ3つのプロジェクトでは不十分か] |
| [例：リポジトリパターン] | [具体的な問題] | [なぜ直接DB アクセスでは不十分か] |


## 進捗追跡
*このチェックリストは実行フロー中に更新される*

**フェーズステータス**:
- [ ] フェーズ0: 調査完了（/planコマンド）
- [ ] フェーズ1: 設計完了（/planコマンド）
- [ ] フェーズ2: タスク計画完了（/planコマンド - アプローチ説明のみ）
- [ ] フェーズ3: タスク生成完了（/tasksコマンド）
- [ ] フェーズ4: 実装完了
- [ ] フェーズ5: 検証通過

**ゲートステータス**:
- [ ] 初期憲章チェック: 合格
- [ ] 設計後憲章チェック: 合格
- [ ] すべての要明確化解決済み
- [ ] 複雑性逸脱ドキュメント化済み

---
*憲章v2.1.1に基づく - `/memory/constitution.md`を参照*
