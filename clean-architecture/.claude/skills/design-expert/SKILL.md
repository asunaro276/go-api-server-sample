---
name: design-expert
description: ソフトウェア設計に関する包括的なガイド。設計パターン、アーキテクチャパターン、設計原則（SOLID、DRYなど）、システム設計、API設計、データモデル設計などに関するアドバイスや実装を求める場合に使用すべきスキルです。クリーンアーキテクチャ、ヘキサゴナルアーキテクチャ、DDDなどのアーキテクチャスタイルにも対応しています。
---

# 設計エキスパート

## 概要

このスキルは、ソフトウェア設計に関する包括的な知識とベストプラクティスを提供します。設計パターン、アーキテクチャパターン、設計原則、システム設計、API設計など、ソフトウェア開発における設計面での意思決定をサポートします。

## クイックスタート

### 基本的な使用パターン

設計に関する質問や実装を依頼する際の基本的なパターン：

```
# 設計パターンの適用
「ユーザー認証システムにFactory Patternを適用してください」

# アーキテクチャの相談
「このマイクロサービスにどのアーキテクチャパターンが適していますか？」

# 設計原則の確認
「このコードはSOLID原則に従っていますか？改善点を教えてください」

# API設計のレビュー
「このREST APIの設計をレビューして、改善点を提案してください」
```

### いつこのスキルを使うべきか

- 新しい機能やモジュールの設計を開始する前
- 既存コードのリファクタリングを検討する時
- アーキテクチャの選択に迷った時
- 設計パターンの適用方法が不明な時
- コードレビューで設計面の改善を提案したい時
- スケーラビリティやメンテナンス性を向上させたい時

## コア設計領域

### 1. 設計パターン

#### 生成パターン（Creational Patterns）

**Singleton Pattern**
- 目的：クラスのインスタンスが1つだけ存在することを保証する
- 使用場面：データベース接続、設定管理、ログシステムなど
- 注意点：グローバル状態を作るため、テストが困難になる可能性がある

**Factory Pattern**
- 目的：オブジェクト生成のロジックをカプセル化する
- 使用場面：データベースの種類に応じたリポジトリの生成、ファイル形式に応じたパーサーの生成
- 利点：インターフェースを通じてオブジェクトを作成し、具体的な実装を隠蔽できる

**Builder Pattern**
- 目的：複雑なオブジェクトの構築過程を段階的に行う
- 使用場面：多数のパラメータを持つオブジェクトの生成、設定オブジェクトの構築
- 利点：可読性の向上、必須パラメータと任意パラメータの明確化

**Prototype Pattern**
- 目的：既存のオブジェクトをクローンして新しいオブジェクトを作成する
- 使用場面：オブジェクトの初期化コストが高い場合、テンプレートベースの生成

#### 構造パターン（Structural Patterns）

**Adapter Pattern**
- 目的：互換性のないインターフェースを持つクラスを一緒に動作させる
- 使用場面：外部ライブラリを内部インターフェースに適合させる、レガシーシステムとの統合
- 利点：既存のコードを変更せずに新しいインターフェースを導入できる

**Decorator Pattern**
- 目的：オブジェクトに動的に新しい責任を追加する
- 使用場面：ロギング、キャッシング、認証、暗号化などの横断的関心事の追加
- 利点：継承を使わずに機能を拡張できる、複数のデコレーターを組み合わせられる

**Facade Pattern**
- 目的：複雑なサブシステムに対してシンプルなインターフェースを提供する
- 使用場面：複雑なライブラリやフレームワークのラッパー、マイクロサービスの統合API
- 利点：サブシステムの複雑さを隠蔽し、使いやすいインターフェースを提供

**Proxy Pattern**
- 目的：他のオブジェクトへのアクセスを制御する代理オブジェクトを提供する
- 使用場面：遅延ロード、アクセス制御、ログ記録、キャッシング
- 種類：仮想プロキシ、保護プロキシ、リモートプロキシ

#### 振る舞いパターン（Behavioral Patterns）

**Strategy Pattern**
- 目的：アルゴリズムのファミリーを定義し、それぞれをカプセル化して交換可能にする
- 使用場面：支払い方法の選択、ソートアルゴリズムの切り替え、バリデーション戦略
- 利点：実行時にアルゴリズムを切り替えられる、条件分岐を削減できる

**Observer Pattern**
- 目的：1対多の依存関係を定義し、状態変化を自動的に通知する
- 使用場面：イベント駆動アーキテクチャ、MVC/MVVMパターン、リアルタイム通知
- 利点：疎結合な通知メカニズム、拡張性の高いイベント処理

**Command Pattern**
- 目的：リクエストをオブジェクトとしてカプセル化する
- 使用場面：アンドゥ/リドゥ機能、タスクキュー、トランザクション処理
- 利点：リクエストのパラメータ化、ログ記録、遅延実行

**Template Method Pattern**
- 目的：アルゴリズムの骨格を定義し、サブクラスで具体的な手順を実装する
- 使用場面：共通のワークフローに対する異なる実装、フレームワーク設計

### 2. アーキテクチャパターン

#### クリーンアーキテクチャ

**主要原則**
1. フレームワーク独立性：フレームワークに依存しない
2. テスト可能性：ビジネスルールはUIやDBなしでテスト可能
3. UI独立性：UIを変更してもビジネスルールは影響を受けない
4. データベース独立性：データベースを簡単に置き換えられる
5. 外部エージェント独立性：ビジネスルールは外部世界について何も知らない

**レイヤー構造**
```
infrastructure/     # インフラストラクチャ層
    ↓ 依存
interface/         # インターフェースアダプター層
    ↓ 依存
usecase/          # アプリケーションビジネスルール層
    ↓ 依存
domain/           # エンタープライズビジネスルール層
```

**依存性の方向**：外側のレイヤーから内側のレイヤーへの一方向のみ

**レイヤーの責務**
- **Domain層**：エンティティ、値オブジェクト、ドメインサービス、リポジトリインターフェース
- **UseCase層**：ユースケース、アプリケーションサービス、入出力ポート
- **Interface層**：コントローラー、プレゼンター、ゲートウェイ、リポジトリ実装
- **Infrastructure層**：フレームワーク、データベース、外部API、設定

#### ヘキサゴナルアーキテクチャ（ポート&アダプター）

**主要概念**
- **アプリケーションコア**：ビジネスロジックを含む、外部依存から独立
- **ポート**：アプリケーションの境界を定義するインターフェース
  - インバウンドポート：外部からアプリケーションへの入力（ユースケース）
  - アウトバウンドポート：アプリケーションから外部への出力（リポジトリ、外部サービス）
- **アダプター**：ポートの具体的な実装
  - プライマリアダプター：アプリケーションを駆動する（HTTP、CLI、gRPC）
  - セカンダリアダプター：アプリケーションによって駆動される（DB、メール、キュー）

**利点**
- ビジネスロジックの独立性
- テスト容易性（モックアダプターの使用）
- 技術スタックの変更が容易

#### レイヤードアーキテクチャ

**構造**
```
プレゼンテーション層（UI/API）
        ↓
  ビジネスロジック層
        ↓
   データアクセス層
        ↓
    データベース
```

**特徴**
- シンプルで理解しやすい
- 各レイヤーが明確な責任を持つ
- 依存の方向が明確（上から下へ）

**課題**
- ビジネスロジックがデータベースに依存しやすい
- 横断的関心事の扱いが難しい

#### マイクロサービスアーキテクチャ

**主要原則**
1. 単一責任：各サービスは1つのビジネス機能を担当
2. 自律性：独立してデプロイ・スケール可能
3. 分散データ：各サービスは独自のデータベースを持つ
4. 障害の分離：1つのサービスの障害が他に波及しない
5. 技術の多様性：サービスごとに異なる技術スタックを選択可能

**設計パターン**
- API Gateway：クライアントとサービス群の間の単一エントリポイント
- Service Discovery：サービスの動的な検出と登録
- Circuit Breaker：障害の連鎖を防ぐ
- Saga Pattern：分散トランザクション管理
- CQRS：読み取りと書き込みの分離

#### イベント駆動アーキテクチャ

**主要概念**
- イベント：システムの状態変化を表す
- イベントプロデューサー：イベントを生成するコンポーネント
- イベントコンシューマー：イベントを受け取って処理するコンポーネント
- イベントチャネル：イベントの伝達経路

**パターン**
- Event Sourcing：すべての状態変化をイベントとして記録
- CQRS：コマンドとクエリを分離
- Pub/Sub：パブリッシュ/サブスクライブパターン

### 3. 設計原則

#### SOLID原則

**S - Single Responsibility Principle（単一責任の原則）**
- 定義：クラスやモジュールは、変更する理由を1つだけ持つべき
- 利点：保守性の向上、テスト容易性、再利用性
- 判断基準：「このコンポーネントを変更する理由は何か？」が複数ある場合は分割を検討

**O - Open/Closed Principle（開放閉鎖の原則）**
- 定義：ソフトウェアエンティティは拡張に対して開いていて、修正に対して閉じているべき
- 実現方法：インターフェース、抽象クラス、依存性注入
- 利点：既存コードを変更せずに新機能を追加できる

**L - Liskov Substitution Principle（リスコフの置換原則）**
- 定義：派生型は、その基本型と置換可能でなければならない
- 意味：インターフェースの契約を守る必要がある
- 違反例：サブタイプが親タイプの前提条件を強化したり、事後条件を弱化したりする

**I - Interface Segregation Principle（インターフェース分離の原則）**
- 定義：クライアントは、使用しないメソッドへの依存を強制されるべきではない
- 実践：大きなインターフェースを小さく、焦点を絞ったインターフェースに分割
- 利点：不要な依存の削減、柔軟性の向上

**D - Dependency Inversion Principle（依存性逆転の原則）**
- 定義：上位モジュールは下位モジュールに依存してはならない。両方とも抽象に依存すべき
- 実現方法：インターフェースへの依存、依存性注入
- 利点：テスト容易性、柔軟性、疎結合

#### DRY原則（Don't Repeat Yourself）

- 定義：同じ知識や意図をシステム内で重複させない
- 適用範囲：コード、データ、ドキュメント
- 注意点：偶然の重複と本質的な重複を区別する

#### KISS原則（Keep It Simple, Stupid）

- 定義：可能な限りシンプルに保つ
- 実践：不要な複雑さを避ける、明確で読みやすいコードを書く
- バランス：シンプルさと拡張性のトレードオフを考慮

#### YAGNI原則（You Aren't Gonna Need It）

- 定義：今必要でない機能は実装しない
- 理由：不要な複雑さの回避、開発時間の削減
- 注意点：将来の拡張性とのバランスを取る

### 4. システム設計

#### スケーラビリティパターン

**水平スケーリング vs 垂直スケーリング**
- 水平：サーバー台数を増やす（スケールアウト）
- 垂直：サーバーのスペックを上げる（スケールアップ）
- 推奨：ステートレスなアプリケーション設計で水平スケーリングを可能にする

**キャッシング戦略**
- Cache-Aside：アプリケーションがキャッシュを管理
- Read-Through：キャッシュがデータソースから自動読み込み
- Write-Through：書き込み時にキャッシュとデータソースを同時更新
- Write-Behind：書き込みを非同期でデータソースに反映

**負荷分散**
- ラウンドロビン：順番にリクエストを振り分け
- 最小接続：接続数が最も少ないサーバーに振り分け
- IPハッシュ：クライアントIPに基づいて振り分け

#### 障害耐性パターン

**Circuit Breaker Pattern**
- 目的：障害のあるサービスへのリクエストを一時的に遮断
- 状態：Closed（正常）、Open（遮断）、Half-Open（試行）
- 利点：障害の連鎖防止、システムの自己修復

**Retry Pattern**
- 実装：指数バックオフ、ジッター
- 注意点：冪等性の確保、最大リトライ回数の設定
- 使用場面：一時的なネットワークエラー、リソースの一時的な枯渇

**Bulkhead Pattern**
- 目的：障害を隔離し、システム全体への影響を防ぐ
- 実装：リソースプールの分離、スレッドプールの分割

**Timeout Pattern**
- 重要性：無限待ちを防ぐ
- 設定：適切なタイムアウト値の決定、タイムアウト後の処理

### 5. API設計

#### RESTful API設計原則

**リソース指向の設計**
```
GET    /api/v1/users          # ユーザー一覧取得
GET    /api/v1/users/:id      # 特定ユーザー取得
POST   /api/v1/users          # ユーザー作成
PUT    /api/v1/users/:id      # ユーザー更新
PATCH  /api/v1/users/:id      # ユーザー部分更新
DELETE /api/v1/users/:id      # ユーザー削除

# ネストしたリソース
GET    /api/v1/users/:id/posts       # 特定ユーザーの投稿一覧
POST   /api/v1/users/:id/posts       # ユーザーの投稿作成
```

**HTTPステータスコードの適切な使用**
- 2xx：成功（200 OK、201 Created、204 No Content）
- 3xx：リダイレクト（301 Moved Permanently、302 Found）
- 4xx：クライアントエラー（400 Bad Request、401 Unauthorized、404 Not Found）
- 5xx：サーバーエラー（500 Internal Server Error、503 Service Unavailable）

**バージョニング戦略**
- URLパス：`/api/v1/users`、`/api/v2/users`
- クエリパラメータ：`/api/users?version=1`
- ヘッダー：`Accept: application/vnd.api+json;version=1`

**ページネーション**
```
# オフセットベース
GET /api/v1/users?page=1&page_size=20

# カーソルベース
GET /api/v1/users?cursor=abc123&limit=20
```

**フィルタリングとソート**
```
GET /api/v1/users?status=active&sort=created_at&order=desc
```

#### GraphQL設計原則

**スキーマファースト設計**
```graphql
type Query {
  user(id: ID!): User
  users(limit: Int, offset: Int): [User!]!
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
}

type User {
  id: ID!
  email: String!
  posts: [Post!]!
}

input CreateUserInput {
  email: String!
  name: String!
}
```

**N+1問題の回避**
- DataLoader パターンの使用
- バッチ処理とキャッシング

### 6. データモデル設計

#### 正規化と非正規化

**正規化（RDBMS）**
```sql
-- 第3正規形
CREATE TABLE users (
    id UUID PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP NOT NULL
);

CREATE TABLE posts (
    id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(id),
    title VARCHAR(255) NOT NULL,
    content TEXT,
    created_at TIMESTAMP NOT NULL
);

CREATE TABLE tags (
    id UUID PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE post_tags (
    post_id UUID REFERENCES posts(id),
    tag_id UUID REFERENCES tags(id),
    PRIMARY KEY (post_id, tag_id)
);
```

**非正規化（NoSQL）**
- 目的：読み取りパフォーマンスの向上
- トレードオフ：データの重複、更新時の複雑さ
- 使用場面：読み取り頻度が書き込みより圧倒的に多い場合

#### ドメイン駆動設計（DDD）

**主要概念**

**エンティティ**
- 特徴：一意の識別子を持つ、ライフサイクルがある
- 例：User、Order、Product

**値オブジェクト**
- 特徴：不変、等価性は値で判断、識別子を持たない
- 例：Email、Address、Money

**集約（Aggregate）**
- 目的：関連するエンティティと値オブジェクトをまとめて整合性を保つ
- 集約ルート：集約への唯一のエントリポイント
- 原則：集約の境界を超えた参照はIDで行う

**リポジトリ**
- 目的：永続化の詳細を隠蔽する
- 原則：集約ルート単位でリポジトリを定義

**ドメインサービス**
- 使用場面：複数のエンティティにまたがるロジック、エンティティに属さないビジネスルール

**ドメインイベント**
- 目的：ドメイン内の重要な出来事を表現
- 利点：疎結合、監査ログ、イベントソーシング

## ベストプラクティス

### 1. 依存性注入（Dependency Injection）

**原則**
- コンストラクタインジェクション：依存を明示的にする
- インターフェースへの依存：具体実装ではなく抽象に依存
- 疎結合：コンポーネント間の結合度を下げる

**利点**
- テスト容易性：モックやスタブを注入できる
- 柔軟性：実装を簡単に切り替えられる
- 保守性：依存関係が明確

### 2. エラーハンドリング

**原則**
- 適切な抽象レベルでエラーを処理
- エラーコンテキストの保持
- リカバリー可能なエラーと不可能なエラーの区別

**パターン**
- カスタムエラー型：ドメイン固有のエラー
- エラーラッピング：コンテキストを追加しながら伝播
- センチネルエラー：特定のエラー条件を表す定数

### 3. 設定管理

**原則**
- 12 Factor App：設定を環境変数で管理
- デフォルト値：合理的なデフォルトを提供
- バリデーション：起動時に設定を検証

**パターン**
- 環境別設定ファイル
- 設定の階層化：デフォルト < 環境 < 実行時

### 4. ロギング

**原則**
- 適切なログレベル：DEBUG、INFO、WARN、ERROR
- 構造化ロギング：JSONなど機械可読な形式
- コンテキスト情報：リクエストID、ユーザーIDなど

**注意点**
- 機密情報のログ出力を避ける
- パフォーマンスへの影響を考慮

### 5. テスタビリティ

**原則**
- 単一責任：テスト対象を明確にする
- 依存性注入：モックを注入できるようにする
- 副作用の分離：純粋な関数とそうでない関数を分ける

**パターン**
- テーブル駆動テスト：複数のテストケースをデータ駆動で実行
- モック/スタブ：外部依存を置き換える
- テストダブル：ダミー、スタブ、スパイ、モック、フェイク

## よくある落とし穴とその回避方法

### 1. 過度な抽象化

**問題**
- 不必要に複雑なレイヤーやインターフェース
- 実際の要件を超えた汎用化

**解決策**
- YAGNI原則に従う
- 実際の要件に基づいて設計する
- 3つのルール：3回同じことをするまで抽象化しない

### 2. 神オブジェクト（God Object）

**問題**
- すべての責任を持つ巨大なクラスやモジュール
- 高い結合度、低い凝集度

**解決策**
- 単一責任原則を適用
- 責任を適切に分離
- ドメイン駆動設計を検討

### 3. 循環依存

**問題**
- モジュールAがBに依存し、BがAに依存する
- コンパイルやテストの困難さ

**解決策**
- 依存性逆転の原則を適用
- インターフェースで依存を切る
- レイヤーの明確化

### 4. プリマチュアオプティマイゼーション

**問題**
- 最初から複雑な最適化を導入
- 実際のボトルネックを測定せずに最適化

**解決策**
- まずはシンプルに実装
- プロファイリングでボトルネックを特定
- 必要になってから最適化

### 5. アンチパターンの適用

**よくあるアンチパターン**
- スパゲッティコード：構造化されていない複雑な制御フロー
- Lava Flow：使われていない古いコードが残る
- Golden Hammer：すべての問題に同じ解決策を適用
- Copy-Paste Programming：コードの重複

**回避方法**
- コードレビュー
- リファクタリングの習慣化
- 技術的負債の定期的な返済

## リファレンス

### バンドルされた参考資料

このスキルには、以下の詳細なリファレンスがバンドルされています：

- `references/design_patterns.md` - 主要な設計パターンの詳細と実装例
- `references/architecture_patterns.md` - アーキテクチャパターンの詳細ガイド
- `references/solid_principles.md` - SOLID原則の深い理解と実践例

これらのリファレンスには、具体的なコード例（Go言語）と詳細な説明が含まれています。

### 推奨リソース

**書籍**
- 『Clean Architecture』Robert C. Martin - アーキテクチャ設計の基本原則
- 『Domain-Driven Design』Eric Evans - DDDの原典
- 『Design Patterns』Gang of Four - 設計パターンの古典
- 『Refactoring』Martin Fowler - リファクタリング技法
- 『Building Microservices』Sam Newman - マイクロサービス設計

**オンラインリソース**
- Martin Fowler's Blog - アーキテクチャとパターンに関する記事
- Microsoft Architecture Guide - 包括的なアーキテクチャガイド
- AWS Architecture Center - クラウドアーキテクチャのベストプラクティス

## 使用上の注意

### このスキルを効果的に使うために

1. **コンテキストを提供する**
   - 現在のアーキテクチャや制約条件を説明してください
   - 使用している技術スタック（言語、フレームワーク）を明示してください

2. **具体的な要件を明記する**
   - スケーラビリティ、メンテナンス性、パフォーマンスなど、優先する品質を伝えてください
   - トレードオフの判断基準を共有してください

3. **既存コードを共有する**
   - リファクタリングの場合は、現在のコード構造を見せてください
   - 問題点や改善したい点を具体的に説明してください

4. **トレードオフを確認する**
   - 設計の選択には必ずトレードオフがあります
   - 要件に応じて最適な選択を検討します

### 設計の進め方

1. **要件の理解**
   - 機能要件：システムが何をすべきか
   - 非機能要件：パフォーマンス、スケーラビリティ、セキュリティなど

2. **ドメインモデリング**
   - ビジネスドメインを理解する
   - 適切な抽象化を見つける
   - ユビキタス言語を定義する

3. **アーキテクチャ選択**
   - システムの特性に合ったアーキテクチャを選ぶ
   - 長期的な保守性を考慮する

4. **パターンの適用**
   - 問題に合った設計パターンを適用する
   - パターンの乱用を避ける

5. **反復的改善**
   - フィードバックを得ながら設計を改善する
   - リファクタリングを継続的に行う

### 重要な考え方

設計は一度で完璧にする必要はありません。継続的に改善していくプロセスです。

- **段階的な改善**：小さな改善を積み重ねる
- **フィードバックループ**：実装、測定、学習のサイクルを回す
- **シンプルさの追求**：複雑さは必要な時だけ導入する
- **チームとのコミュニケーション**：設計の意図を共有する
